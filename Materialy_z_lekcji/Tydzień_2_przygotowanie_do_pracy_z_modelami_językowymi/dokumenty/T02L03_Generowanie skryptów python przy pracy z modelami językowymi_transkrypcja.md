Dzień dobry. uczyć narzędzi no-code. One zastępują te skrypty Python, ale niekiedy Python jest po prostu bardziej wygodny, lepszy i szybszy do różnych zastosowań, do przeparzenia danych, zwłaszcza jak coś potrzebujemy przerobić na przykład jednorazowo. Zacznę od tego, żeby powiedzieć, jakie modele językowe w obecnym rzeczywistości, czyli w maju 2025, są najlepsze w programowaniu. Więc takim powiedzmy najlepszym wyborem wśród społeczności są modele Clode. i tutaj mam na myśli Clode 3.7 Sonnet i Clode 3.5 Sonnet. Oczywiście możemy z nich tutaj skorzystać w Clode, możemy też na przykład z nich skorzystać w kursorze, czego będziesz się uczyć, natomiast to są dwa, które są bardzo popularne. Drugimi bardzo popularnymi modelami do programowania są modele Gemini i szczególnie tutaj mam na myśli Gemini 2.5 Flash Preview i Gemini 2.5 Pro Preview. I to są takie główne modele, które są wykorzystywane w programowaniu. Modele OpenAI raczej nie słyną z tego, że są poprawne w programowaniu. ten model nowy GPT-4-1, on co prawda trochę jest tym lepszy, natomiast zazwyczaj przy programowaniu będziemy się ograniczali do tych czterech modeli językowych. I to, co na początku musimy zrobić, żeby generować skrypty w Pythonie, to musimy przekazać jakieś zasady modelowi językowemu. Więc polecam Ci taką stronę, która nazywa się Cursor Directory. Ona służy do tego, żeby wrzucać te komendy do kursora jako powiedzmy takie instrukcje systemowe, natomiast możemy tych instrukcji systemowych użyć też do innych zastosowań. Ten link znajduje się w GitHubie, w repo, więc tutaj wybieramy po prostu technologię, w której pracujemy. Akurat w przypadku Pythona jest 15 różnych, powiedzmy, promptów systemowych, które mogą pomóc nam programować Pythonie, więc możemy wziąć jedną z tych instrukcji systemowych, Możemy ją też zmodyfikować, dopisując informacje, że na przykład programujemy w Google Collab, żeby na przykład zawsze model tworzył instrukcje systemowe i teraz musimy gdzieś tą rules przenieść. Robert w swoim pierwszym tygodniu pokazywał, jak tworzyć custom GPTs, więc oczywiście możemy to samo tutaj zrobić. możemy stworzyć custom GPT, który będzie zawierał po prostu tą instrukcję systemową, czyli jak stworzę custom GPT, to tutaj w instrukcjach po prostu wklejam te customowe instrukcje i wtedy ten custom GPT będzie już służył do tego, żeby programować. To samo mogę zrobić w ramach rozwiązań Clode'a i tutaj po prostu jest coś takiego jak Clode Projects i tutaj mogę stworzyć nowy projekt i w ramach tego projektu też mu opisać co konkretnie chcemy jako instrukcję systemu tutaj zastosować. To samo mogę zrobić w Google Gemini. Czekaj, chwilkę. No tutaj. To samo mogę zrobić w Google Gemini, korzystając tutaj z ikonki system instruction i przeklejając te wszystkie zasady, które tutaj są spisane. Oczywiście mogę jeszcze więcej zasad dopisać, natomiast to jest taki punkt dobry wyjścia, żeby model wiedział, w jaki sposób ma programować. Mogę też wykorzystać jakieś gotowe rozwiązania w ramach na przykład chatu GPT. Oczywiście, tak jak powiedziałem, modele chatu GPT nie są najlepsze w programowaniu, natomiast w kontekście prostych skryptów Python one też na pewno sobie poradzą. I możemy wyszukać jakiś GPT, który służy do programowania. Możemy na przykład skorzystać z tego. Jego link też znajdziesz w materiałach. Ten akurat GPT ma po prostu bardzo dużo dokumentacji różnych bibliotek Pythonowych wgranych i można po prostu z niego skorzystać. On działa, ja go testowałem, jest całkiem sprawny. To, co jest jednak najbardziej kluczowe w kontekście generowania skryptów, to jest rozbijanie naszych projektów na małe kawałki. Załóżmy, że masz jakiś projekt, który chcesz zrealizować za pomocą skryptów Python, na przykład jest to, nie wiem, generowanie nagłówków za pomocą modeli językowych, to musisz się po prostu zastanowić, jakie kroki prowadzą do wygenerowania nagłówków. Czyli na przykład keyword research, czyli na przykład ekstrakcja faktów z treści, i dopiero generowanie nagłówków, więc trzeba wtedy napisać trzy oddzielne skrypty i trzy oddzielne skrypty uruchomić w Google Colabie. Nie należy pisać takich skryptów, które zawierają bardzo wiele operacji w jednym skrypcie. Każdy skrypt w Pythonie powinniśmy pisać jako taki mały mikroserwis, ponieważ modele językowe dobrze sobie radzą w programowaniu, ale jeżeli to jest takie krótkie programowanie, jeżeli ten codebase jest duży i na dużym codebase ma operować model językowy, no to najczęściej będzie bardzo trudno zapanować nad takim codebase'em i te skrypty po prostu przestaną w pewnym czasie działać. Ok, i teraz jak my generujemy? Załóżmy, że mam tą instrukcję systemową i mam ten tutaj Gemini 2.5 Pro, którego użyjemy w tym konkretnym przykładzie, to tutaj po prostu musimy opisać tak dokładnie, co my chcemy zrobić. Chciałbym skrypt, który pobierze wyniki top 10 na określone słowo kluczowe z API SerpData IO. No i tutaj podaję mu przykładowe zapytanie. Przechodzę na tą stronę SerpData.io, do której masz też dostęp API. Wybieram język Python tutaj. Przekazuję mu tutaj przykładowe zapytanie. Przykładowa odpowiedź. definiuje jeszcze co ma ten model tutaj jeszcze skonfigurować czyli chciałbym aby skrypt zapisywał do data frame top 10 wyników z tablicy z obiektu obiektu organic które mają mniejszy niż 10. I tutaj jeszcze mogę zapisać, programuję Google Colab, więc wykorzystaj opcje interaktywnych formularzy do ustawienia zmiennych. Mogę jeszcze dopisać na przykład dodaj jeszcze i tu bardzo ważne, Zazwyczaj, jeżeli mamy taką ogólną instrukcję, to powinniśmy jeszcze poprosić model, żeby najpierw przed wygenerowaniem skryptu napisał dokładny plan i po jego zatwierdzeniu dopiero piszemy skrypt. Zanim wygenerujesz... Oczywiście to mogłem jeszcze do instrukcji systemowej przenieść, żeby za każdym razem to robił. Zanim wygenerujesz skrypt, wygeneruj plan działania i opis działania po jego zatwierdzeniu wygeneruj OK, i teraz uruchamiam i ten model powinien się zastanowić, w jaki sposób ten skrypt wygenerować i jak on rozumie konkretnie tę instrukcję, czyli będziesz miał pewność, miała pewność, że on dokładnie rozumie, co my chcieliśmy mu przekazać. Ok, czyli on zainstaluje biblioteki, zaimportuje, definiowanie kluczy wejściowych, przygotowanie zapytania API, wykonywanie zapytania API, przetwarzanie odpowiedzi, ekstrakcja i filtrowanie wyników organicznych, tworzenie ramki danych, wyświetlanie wyników. No i to jest ok. O to mi chodziło i on teraz wygeneruje ten skrypt i zobaczymy, czy on będzie działał. Ok, mamy ten skrypt, więc teraz musimy go gdzieś uruchomić. W naszym przypadku będzie tu Google Collab, więc wchodzę na stronę Google Collab i tworzę nowy notebook wrzucam to jako ramkę i tutaj mnie prosi o key API to przekazuję mu key API, który mamy tutaj oczywiście możemy też skorzystać to jest sekret key, to tutaj musimy jeszcze dodatkowo określić modelowi i wpisuję keyword na przykład SEO no i zobaczymy czy za pierwszym razem to zadziała Tak. mamy kluczapi, słowo kluczowe, wysyłanie żądania, ok, przetworzył i tutaj właśnie brak wyników, prawdopodobnie nie znaleziono wyników, więc tutaj mamy jakiś błąd i teraz jak widzicie tutaj w konsoli mamy wyświetlone informacje, które model otrzymał, więc które otrzymaliśmy, więc możemy przekazać modelowi jaki jest błąd, prawda, więc wrócę do tego, otrzymuję taki błąd. Ja już wiem z czego wynika ten błąd, po prostu on źle zdefiniował nazwę klucza, w której znajdują się wyniki organiczne, więc na przykład możemy mu po prostu też zasugerować odpowiedź. OK. Zawiesił się. Hejt. Z jakiegoś powodu wykrył, że stosujemy jakiś hejt. No i spróbujemy wygenerować ponownie. Tak zazwyczaj to działa, że po prostu potrzebujemy kilku iteracji. Nie skupiałem się na tym, żeby ten skrypt od razu był poprawny, właśnie żeby pokazać jak też te błędy eliminować. Co on tutaj napisał? Przeczytajmy, masz rację, przepraszam za błąd, analizując dostarczoną odpowiedzi strukturę odpowiedzi, widzę, że faktycznie klucz Organic jest zagnieżony głębiej, czyli po prostu źle sparsował odpowiedź JSON ZAPI, więc wrócę, ponownie wrzucę ten skrypt. Pamiętaj, że Gemini też jest tutaj dostępny. On aktualnie, kiedy nagryłam ten kurs, nie działa akurat możliwość wygenerowania kodu, ale może go wyjaśnić na przykład. I tutaj ponownie niestety musimy wkleić klucz, dlatego polecam korzystać z Secret Key, bo wtedy nie musimy ponownie tego robić, bo zazwyczaj po pierwsze nie powinniśmy wysyłać kluczy do modeli językowych, a po drugie on za każdym razem, kiedy zobaczy, że wysyłamy jakiś klucz, to on go czyści. Tutaj akurat na to nie zwracają uwagi, ponieważ ten klucz pozwala pobrać tylko 25 wyników i później po prostu zostanie skasowany, ale jest to ważne. Ponownie wysyłamy to żądanie. Okej, no i mamy tutaj właśnie sparsowane to żądanie. Możemy przejść dalej z tym. No i tak generalnie, jak tutaj to zrobiłem, to mógłbym po prostu dalej generować kolejne kroki tego procesu w zależności od tego, co ten skrypt miałby dalej robić. Jeżeli chciałbym nad tym sobie po prostu pracować jeszcze i wygenerowałbym taki duży skrypt, taki duży kolab, który zawierałby wiele skryptów, to mogę go po prostu pobrać, czyli możemy stworzyć nowy projekt, na przykład skrypt do generowania top 10. Tu możemy opisać, co chcemy osiągnąć, niekoniecznie to musimy robić i tu mamy dostęp do instrukcji systemowych, więc możemy tą instrukcję systemową tutaj wgrać i jak będziemy sobie czatować z tym klodę, to on będzie korzystał zawsze z tej instrukcji systemowej. Mamy też możliwość wrzucania plików, o czym też powiem, więc on będzie po prostu dostosowany do tego, że chcemy programować w Pythonie. I to w zasadzie tyle w tej lekcji. W lekcjach o programowaniu nauczysz się znacznie bardziej skomplikowanych operacji na kodzie, natomiast na tyle to ci wystarczy, żeby poradzić sobie z lekcjami do momentu programowania z AI. Zachęcam do tego, żeby eksperymentować z Pythonem, bo przy wykorzystaniu tych modeli, o których powiedziałem, naprawdę jest to proste i te kody, które potem będę pokazywał w kolejnych lekcjach, one po prostu wydadzą Ci się znacznie łatwiejsze. Więc bardzo to polecam i zapraszam do oglądania kolejnych lekcji.